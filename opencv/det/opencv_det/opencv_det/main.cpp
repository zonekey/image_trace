////  main.cpp//  opencv_det////  Created by 孙玮 on 14/11/25.//  Copyright (c) 2014年 孙玮. All rights reserved.//#include <iostream>#include <opencv2/opencv.hpp>#include <opencv2/gpu/gpu.hpp>#include <string>#include <opencv2/nonfree/nonfree.hpp>#include <opencv2/objdetect/objdetect.hpp>#include <opencv2/highgui/highgui.hpp>#include <sstream>#define CASCADE_CLASSIFIER_FNAME "/opt/local/share/OpenCV/haarcascades/haarcascade_frontalface_default.xml"// 找特征点, 并画出..static void show_feathers(cv::Mat &pic){    std::vector<cv::KeyPoint> keypoints, keypoints2;    std::vector<cv::KeyPoint>::const_iterator it;    cv::FastFeatureDetector ffd(20);    ffd.detect(pic, keypoints);        cv::SurfFeatureDetector sfd;    sfd.detect(pic, keypoints2);        for (it = keypoints.begin(); it != keypoints.end(); ++it) {        cv::circle(pic, it->pt, 2, CV_RGB(255, 0, 0));    }        for (it = keypoints2.begin(); it != keypoints2.end(); ++it) {        cv::circle(pic, it->pt, 2, CV_RGB(0, 255, 0));    }}static std::vector<cv::Rect> det_faces(cv::CascadeClassifier *cc, cv::Mat &frame){    std::vector<cv::Rect> faces;    cc->detectMultiScale(frame, faces);    return faces;}struct Context{    cv::CascadeClassifier *cc;    cv::Mat current_frame;        bool mouse_pressed;    cv::Point first_pt, second_pt;        size_t positive_cnt, negative_cnt;};// 进行任何处理 ...static void run_one_frame(Context &ctx, cv::Mat &frame){    //show_feathers(frame);//    std::vector<cv::Rect> faces = det_faces(ctx.cc, frame);//    for (std::vector<cv::Rect>::const_iterator it = faces.begin(); it != faces.end(); ++it) {//        cv::rectangle(frame, *it, cv::Scalar(0., 255.0), 2);//    }}static void mouse_callback(int event, int x, int y, int flags, void* userdata){    struct Context *ctx = (struct Context*)userdata;        bool &pressed = ctx->mouse_pressed;        switch (event) {        case cv::EVENT_LBUTTONDOWN:            pressed = true;            ctx->first_pt = cv::Point(x, y);            ctx->second_pt = ctx->first_pt;            break;                    case cv::EVENT_LBUTTONUP:            if (pressed) {                pressed = false;                                ctx->second_pt = cv::Point(x, y);                cv::Rect rc(ctx->first_pt, ctx->second_pt);                if (rc.area() < 100) {                    std::cout << "the rect area tooooo small!" << std::endl;                }                else if (rc.width /2 > rc.height || rc.height / 2 > rc.width) {                    std::cout << "the rect is tooooo flat!" << std::endl;                }                else {                    // TODO: save image ..                    cv::Mat m(ctx->current_frame, rc);                    std::stringstream ss;                    ss << "positive_" << ctx->positive_cnt++ << ".jpg";                    cv::imwrite(ss.str(), m);                }            }                    case cv::EVENT_MOUSEMOVE:            if (pressed) {                ctx->second_pt = cv::Point(x, y);            }                    default:            break;    }}int main(int argc, const char * argv[]){    std::cout << cv::getBuildInformation() << std::endl;        cv::namedWindow("main");    cv::VideoCapture cap(0);    bool quit = false;    Context ctx;    cv::CascadeClassifier cc;        ctx.cc = &cc;    ctx.positive_cnt = ctx.negative_cnt = 0;        cc.load(CASCADE_CLASSIFIER_FNAME);        cv::setMouseCallback("main", mouse_callback, &ctx);        while (!quit) {        cap >> ctx.current_frame;                run_one_frame(ctx, ctx.current_frame);                if (ctx.mouse_pressed) {            cv::Rect rc(ctx.first_pt, ctx.second_pt);            cv::rectangle(ctx.current_frame, rc, cv::Scalar(0, 0, 255), 2);        }        cv::imshow("main", ctx.current_frame);                if (cv::waitKey(10) == 27) {            quit = true;        }    }    return 0;}